% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Foo_Bot.R
\name{Foo_Bot}
\alias{Foo_Bot}
\title{Foo_Bot}
\usage{
Foo_Bot(Bot_Name = NULL, Info_Loc = NULL, Token = NULL,
  Function_List = NULL, LoadMessage = "\\nConnection established with R\\n",
  KillR = TRUE, PokePC = TRUE, RestartCPU = FALSE, KillCPU = FALSE)
}
\arguments{
\item{Bot_Name}{Name of the bot to do the sending.}

\item{Info_Loc}{Where the RDS file with your needed bot info is saved. Defaults to path.expand("~")}

\item{Token}{Token of your bot if not using the saved file call from Rbot::Add_Bot()}

\item{Function_List}{Function_List containing for each function: The function to be called, the call handle, as well as the message sent to Telegram. Up to 20 functions can be added.}

\item{LoadMessage}{What to display on your phone when this call is initialised}

\item{KillR}{Add option to kill R from your phone. Default to TRUE}

\item{PokePC}{Ping the PC and check that your connection is still active. No side-effects, simple poke message returned.}

\item{RestartCPU}{Force restarts the PC - no questions asked. Defaults to FALSE.}

\item{KillCPU}{Add option to turn off your computer completely, no questions asked. Default to FALSE. Useful if working e.g. on a public CPU that you want to log out from remotely.}
}
\value{
Switches R on to listen for Bot
}
\description{
Execute functions in R from your phone.
This will require an open R session connected to your phone.
Using this function, you can specify the functions that R will execute
on your demand.
}
\examples{
\dontrun{
# Provide a Function_List with the the following inputs per function:

# Function_List$Foo1, Function_List$Foo2, ... : can provide up to 30 functions
# Function_List$Call : What to type in Telegram. Used as /Call in Telegram
# Function_List$Args : TRUE / FALSE; whether to be able to include an argument. If excluded, it defaults to FALSE.
# Function_List$Message : How to describe this function in Telegram.
# Example below:

Function_List <- list()

First_Foo <- function(X){

  Inputs <- eval(parse(text = X))

  Msg_Foo <- function(Arg1, Arg2, Arg3, TFalse) {

     if(TFalse == TRUE) message(paste(Arg1, Arg2, Arg3, sep = "/n"))

  }

  Msg_Foo(Arg1 = Inputs["Arg1"],
          Arg2 = Inputs["Arg2"],
          Arg3 = Inputs["Arg3"],
          TFalse = Inputs["TFalse"]
  )

  message("R Msg: ....Function 1 executed....")

}

Function_List$Foo1 <-
  list(Function = First_Foo,
# How to call your function from Telegram
       Call = "F1",
       Args = TRUE,
       # Describe Function in Telegram
       Message = "Type four arguments as:\\nc(Arg1 = 'First Argument', Arg2 = 'Second Argument', Arg3 = 'Third and Last', TFalse = 'FALSE')\\nPlan the function you source to fit this convention."
  )

Second_Foo <- function(X){

  Inputs <- eval(parse(text = X))
  print(paste0("Your provided input: ", Inputs) )
  message("R Msg: ....Function 2 executed....")

}


Function_List$Foo2 <-
  list(Function = Second_Foo,
       Call = "F2",
       Args = TRUE,
       # Describe Function in Telegram
       Message = "Second Function Call...")



Error_Foo <- function(){
  x <- 0
  if( is.infinite(10/x)) stop("Example of error being thrown, but not breaking connection...")

}

Function_List$Foo3 <-
  list(Function = Error_Foo,
       Call = "Error_Example",
       Args = TRUE,
       Message = "\\nError function illustrated: \\nThis illustrates that the connection with the phone will  be preserved using purrr::safely")



Bot_Name <- "A"
Foo_Bot(Bot_Name = Bot_Name, Function_List = Function_List, LoadMessage = "My connection with R",
       KillR = TRUE, KillCPU = FALSE)

# Alternatively, no Function_List (implying only ability to switch off computer or killR, e.g.):

# Foo_Bot(Bot_Name = Bot_Name, Function_List = NULL, LoadMessage = "My connection with R",
#         KillR = TRUE, KillCPU = FALSE)


}
}
